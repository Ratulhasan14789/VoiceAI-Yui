from numpy.random import choice as chimport sys"""This code encrypts a string into another string, following thes steps:- first the strings is sliced to 8 vertices cubic strings (as many as needed). The letters are successively placed at vertices following the coordinates:(0,0,0)->(0,1,0)->(1,1,0)->(1,0,0)->(0,0,1)->(0,1,1)->(1,1,1)->(1,0,1)- then the cubes are randomly rotated, a random number of times, independantly, up, down, left or right.- the resulting cube positions are being read following the same path, producing the encrypted string.- the code also embeds the reverse - decrypting - function."""text = "I aml"encrypted = "t I oamoie tllingt  enoti  ed"key = ""# INPUT instructions:# - text:# Because of limited display in the CP, 40 chars is the max length on (some) phones,# for the cubes to be printed nicely, but encrypt/decrypt sill works fine over 40 chars.# text will be encrypted, then decrypted if 'crypted' is left blank# - crypted:# you can use this line to decrypt a specific string# careful that if the original message didn't fit exactly the last cube, its corresponding crypted message has spaces in it# ex: "abcdefghijkl" + "0:U,1:L" --> "eadhfbcglk  ij  ".# Thus, if you want to decrypt a string, you'll need those spaces.# - key:# the encryption/decryption key will be produced randomly if key is left blank# write your key following next example syntax:# "0:U:U:L,1:L,2:R:R:U:R,3:D:L:D,4:R:U,5:D:D:L:D:L"# Be careful to calculate the number of cubes before defining a key !# It won't crash if you give too many instructions, but it will if not enough.# --------------------------------# formating input if some:cub = lambda x:([(list(x)+[' ']*7)[i*8:(i+1)*8]for i in range((len(x)+7)//8)])encrypted = encrypted and cub(encrypted)key = key and [i[2:].split(":") for i in key.split(",")]# --------------------------------# producing the cubes list:# -list of 8 string chars for each cube-cubes = cub(text)# producing a random key:# -list of a random number of rotation directions for each cube-key= key or [[*ch(list("UDLR"),ch(range(1,6)))]for i in range((len(text)+7)//8)]if len(key)<len(cubes):    sys.exit("Not enough instructions in your key!")# rotation function for one cube (recursive):# (based on the four movements in mov)mov = ["40375126","15620473","32670154","45107623"]rot = lambda c,k:[rot(c,k[:-1])[int(i)] for i in mov["UDLR".index(k[-1])]] if len(k)>=1 else c# producing the list of encrypted cubes:encrypted = encrypted or [rot(cubes[i],key[i]) for i in range(len(cubes))]# decrypting the encrypted message:# (reversing the key first)rev_k = [["DURL"["UDLR".index(j)]for j in k][::-1]for k in key]decrypted = [rot(encrypted[i],rev_k[i])for i in range(len(cubes))]# --------------------------------# The cube-printing onelined function:print3D = lambda x:print('\n','\n'.join([''.join(["  {}--{}  /{}{}/| {}--{} | | {}| {} |{}{}|/  {}--{}   "[i*9:(i+1)*9].format(*[(j[5],j[6]),(" "," "),(j[1],j[2]),(j[4],j[7]),(" "," "),(j[0],j[3])][i]) for j in x]) for i in range(6)]),'\n',sep='')# --------------------------------# PRINTING TIMEprint("Message:",text)print3D(cubes)# printing the key:print("Key:",','.join([':'.join([str(i)]+key[i])for i in range(len(key))]))# printing the encrypted cubes:print3D(encrypted)# printing the encrypted text:print("Enrypted message:",''.join(''.join(i)for i in encrypted))# printing the decrypted messageprint("Decrypted message:",''.join(''.join(i)for i in decrypted))